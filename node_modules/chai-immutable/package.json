{
  "_args": [
    [
      {
        "raw": "chai-immutable",
        "scope": null,
        "escapedName": "chai-immutable",
        "name": "chai-immutable",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "/Users/sunnlamp/workspace/voting-server"
    ]
  ],
  "_from": "chai-immutable@latest",
  "_id": "chai-immutable@1.6.0",
  "_inCache": true,
  "_location": "/chai-immutable",
  "_nodeVersion": "4.4.5",
  "_npmOperationalInternal": {
    "host": "packages-16-east.internal.npmjs.com",
    "tmp": "tmp/chai-immutable-1.6.0.tgz_1465620232842_0.34194417716935277"
  },
  "_npmUser": {
    "name": "astorije",
    "email": "jeremie@astori.fr"
  },
  "_npmVersion": "2.15.5",
  "_phantomChildren": {},
  "_requested": {
    "raw": "chai-immutable",
    "scope": null,
    "escapedName": "chai-immutable",
    "name": "chai-immutable",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#DEV:/",
    "#USER"
  ],
  "_resolved": "https://registry.npmjs.org/chai-immutable/-/chai-immutable-1.6.0.tgz",
  "_shasum": "9ec00bdd67948b13b20fcbb89cbf4af2ce6f9247",
  "_shrinkwrap": null,
  "_spec": "chai-immutable",
  "_where": "/Users/sunnlamp/workspace/voting-server",
  "author": {
    "name": "Jérémie Astori",
    "url": "https://jeremie.astori.fr"
  },
  "bugs": {
    "url": "https://github.com/astorije/chai-immutable/issues"
  },
  "dependencies": {},
  "description": "Chai assertions for Facebook's Immutable library for JavaScript collections",
  "devDependencies": {
    "chai": "^3.4.0",
    "coveralls": "^2.11.9",
    "immutable": "^3.7.5",
    "istanbul": "^0.4.3",
    "jscs": "^2.5.0",
    "mocha": "^2.4.5"
  },
  "directories": {
    "test": "test"
  },
  "dist": {
    "shasum": "9ec00bdd67948b13b20fcbb89cbf4af2ce6f9247",
    "tarball": "https://registry.npmjs.org/chai-immutable/-/chai-immutable-1.6.0.tgz"
  },
  "gitHead": "954d3478530b65743c4180197a178ebaffa232a1",
  "homepage": "https://github.com/astorije/chai-immutable",
  "keywords": [
    "chai",
    "chai-plugin",
    "browser",
    "test",
    "assertions",
    "immutable"
  ],
  "license": "MIT",
  "main": "chai-immutable.js",
  "maintainers": [
    {
      "name": "astorije",
      "email": "jeremie@astori.fr"
    }
  ],
  "name": "chai-immutable",
  "optionalDependencies": {},
  "peerDependencies": {
    "chai": ">= 2.0.0 < 4"
  },
  "readme": "[![npm Version](https://img.shields.io/npm/v/chai-immutable.svg)](https://npmjs.org/package/chai-immutable)\n[![License](https://img.shields.io/npm/l/chai-immutable.svg)](LICENSE)\n[![Build Status](https://travis-ci.org/astorije/chai-immutable.svg?branch=master)](https://travis-ci.org/astorije/chai-immutable)\n[![Build Status](https://ci.appveyor.com/api/projects/status/407ts84pq7wd4kt9/branch/master?svg=true)](https://ci.appveyor.com/project/astorije/chai-immutable/branch/master)\n[![Coverage Status](https://coveralls.io/repos/astorije/chai-immutable/badge.svg)](https://coveralls.io/r/astorije/chai-immutable)\n[![devDependency Status](https://david-dm.org/astorije/chai-immutable/dev-status.svg)](https://david-dm.org/astorije/chai-immutable#info=devDependencies)\n[![peerDependency Status](https://david-dm.org/astorije/chai-immutable/peer-status.svg)](https://david-dm.org/astorije/chai-immutable#info=peerDependencies)\n\n# Chai Immutable\n\nThis plugin provides a set of [Chai](http://chaijs.com/) assertions for [Facebook's Immutable library for JavaScript collections](http://facebook.github.io/immutable-js/).\n\n## Installation\n\n### Node.js\n\nInstall via [npm](http://npmjs.org):\n\n```bash\nnpm install chai-immutable\n```\n\nYou can then use this plugin as any other Chai plugins:\n\n```js\nvar chai = require('chai');\nvar chaiImmutable = require('chai-immutable');\n\nchai.use(chaiImmutable);\n```\n\n### In the browser\n\nInclude this plugin after including Chai and Immutable. It will automatically\nplug in to Chai and be ready for use:\n\n```html\n<script src=\"chai-immutable.js\"></script>\n```\n\n### Using `chai-immutable` with other plugins\n\nIf you are using this plugin with\n[`chai-as-promised`](https://github.com/domenic/chai-as-promised/) or\n[`dirty-chai`](https://github.com/prodatakey/dirty-chai), note that\n`chai-immutable` must be loaded **before** any of them. For example:\n\n```js\nvar chai = require('chai');\nvar chaiAsPromised = require('chai-as-promised');\nvar chaiImmutable = require('chai-immutable');\nvar dirtyChai = require('dirty-chai');\nvar expect = chai.expect;\n\nchai.use(chaiImmutable);\nchai.use(dirtyChai);\nchai.use(chaiAsPromised);\n\nvar List = require('immutable').List;\n\n/* ... */\nreturn expect(List.of(1, 2, 3)).to.eventually.have.size(3);\nexpect(true).to.be.true();\n```\n\n## BDD API Reference\n\n### .empty\n\nAsserts that the immutable collection is empty.\n\n```js\nexpect(List()).to.be.empty;\nexpect(List.of(1, 2, 3)).to.not.be.empty;\n```\n\n### .equal(collection)\n\n- **@param** *{ Collection }* collection\n\nAsserts that the values of the target are equivalent to the values of\n`collection`. Aliases of Chai's original `equal` method are also supported.\n\n```js\nvar a = List.of(1, 2, 3);\nvar b = List.of(1, 2, 3);\nexpect(a).to.equal(b);\n```\n\nImmutable data structures should only contain other immutable data\nstructures (unlike `Array`s and `Object`s) to be considered immutable and\nproperly work against `.equal()`. See\n[this issue](https://github.com/astorije/chai-immutable/issues/24) for\nmore information.\n\nAlso, note that `deep.equal` and `eql` are synonyms of `equal` when\ntested against immutable data structures, therefore they are aliases to\n`equal`.\n\n### .include(value)\n\n- **@param** *{ Mixed }* val\n\nThe `include` and `contain` assertions can be used as either property\nbased language chains or as methods to assert the inclusion of a value\nin an immutable collection. When used as language chains, they toggle the\n`contains` flag for the `keys` assertion.\n\n```js\nexpect(new List([1, 2, 3])).to.include(2);\nexpect(new Map({ foo: 'bar', hello: 'universe' })).to.include.keys('foo');\n```\n\n### .keys(key1[, key2, ...[, keyN]])\n\n- **@param** *{ String... | Array | Object | Collection }* key*N*\n\nAsserts that the keyed collection contains any or all of the passed-in\nkeys. Use in combination with `any`, `all`, `contains`, or `have` will\naffect what will pass.\n\nWhen used in conjunction with `any`, at least one key that is passed in\nmust exist in the target object. This is regardless whether or not\nthe `have` or `contain` qualifiers are used. Note, either `any` or `all`\nshould be used in the assertion. If neither are used, the assertion is\ndefaulted to `all`.\n\nWhen both `all` and `contain` are used, the target object must have at\nleast all of the passed-in keys but may have more keys not listed.\n\nWhen both `all` and `have` are used, the target object must both contain\nall of the passed-in keys AND the number of keys in the target object must\nmatch the number of keys passed in (in other words, a target object must\nhave all and only all of the passed-in keys).\n\n`key` is an alias to `keys`.\n\n```js\nexpect(new Map({ foo: 1 })).to.have.key('foo');\nexpect(new Map({ foo: 1, bar: 2 })).to.have.keys('foo', 'bar');\nexpect(new Map({ foo: 1, bar: 2 })).to.have.keys(new List(['bar', 'foo']));\nexpect(new Map({ foo: 1, bar: 2 })).to.have.keys(new Set(['bar', 'foo']));\nexpect(new Map({ foo: 1, bar: 2 })).to.have.keys(new Stack(['bar', 'foo']));\nexpect(new Map({ foo: 1, bar: 2 })).to.have.keys(['bar', 'foo']);\nexpect(new Map({ foo: 1, bar: 2 })).to.have.keys({ 'bar': 6, 'foo': 7 });\nexpect(new Map({ foo: 1, bar: 2 })).to.have.keys(new Map({ 'bar': 6, 'foo': 7 }));\nexpect(new Map({ foo: 1, bar: 2 })).to.have.any.keys('foo', 'not-foo');\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys('foo', 'bar');\nexpect(new Map({ foo: 1, bar: 2 })).to.contain.key('foo');\n```\n\n### .property(name, [value])\n\n- **@param** *{ String | Array | Iterable }* name\n- **@param** *{ Mixed }* value (optional)\n\nAsserts that the target has a property `name`, optionally asserting that\nthe value of that property is equal to `value`. `value` can be an\nImmutable object.\nIf the `deep` flag is set, you can use dot- and bracket-notation for deep\nreferences into objects and arrays.\n\n```js\n// Simple referencing\nvar map = new Map({ foo: 'bar' });\nexpect(map).to.have.property('foo');\nexpect(map).to.have.property('foo', 'bar');\n\n// Deep referencing\nvar deepMap = new Map({\n    green: new Map({ tea: 'matcha' }),\n    teas: new List(['chai', 'matcha', new Map({ tea: 'konacha' })])\n});\n\nexpect(deepMap).to.have.deep.property('green.tea', 'matcha');\nexpect(deepMap).to.have.deep.property(['green', 'tea'], 'matcha');\nexpect(deepMap).to.have.deep.property(new List(['green', 'tea']), 'matcha');\nexpect(deepMap).to.have.deep.property('teas[1]', 'matcha');\nexpect(deepMap).to.have.deep.property(['teas', 1], 'matcha');\nexpect(deepMap).to.have.deep.property(new List(['teas', 1]), 'matcha');\nexpect(deepMap).to.have.deep.property('teas[2].tea', 'konacha');\nexpect(deepMap).to.have.deep.property(['teas', 2, 'tea'], 'konacha');\nexpect(deepMap).to.have.deep.property(new List(['teas', 2, 'tea']), 'konacha');\n```\n\nYou can also use a `List` as the starting point of a `deep.property`\nassertion, or traverse nested `List`s.\n\n```js\nvar list = new List([\n  new List(['chai', 'matcha', 'konacha']),\n  new List([\n    new Map({ tea: 'chai' }),\n    new Map({ tea: 'matcha' }),\n    new Map({ tea: 'konacha' })\n  ])\n]);\n\nexpect(list).to.have.deep.property('[0][1]', 'matcha');\nexpect(list).to.have.deep.property([0, 1], 'matcha');\nexpect(list).to.have.deep.property(new List([0, 1]), 'matcha');\nexpect(list).to.have.deep.property('[1][2].tea', 'konacha');\nexpect(list).to.have.deep.property([1, 2, 'tea'], 'konacha');\nexpect(list).to.have.deep.property(new List([1, 2, 'tea']), 'konacha');\n```\n\nFurthermore, `property` changes the subject of the assertion\nto be the value of that property from the original object. This\npermits for further chainable assertions on that property.\n\n```js\nexpect(map).to.have.property('foo')\n  .that.is.a('string');\nexpect(deepMap).to.have.property('green')\n  .that.is.an.instanceof(Map)\n  .that.equals(new Map({ tea: 'matcha' }));\nexpect(deepMap).to.have.property('teas')\n  .that.is.an.instanceof(List)\n  .with.deep.property([2])\n    .that.equals(new Map({ tea: 'konacha' }));\n```\n\nNote that dots and brackets in `name` must be backslash-escaped when\nthe `deep` flag is set, while they must NOT be escaped when the `deep`\nflag is not set.\n\n```js\n// Simple referencing\nvar css = new Map({ '.link[target]': 42 });\nexpect(css).to.have.property('.link[target]', 42);\n\n// Deep referencing\nvar deepCss = new Map({ '.link': new Map({ '[target]': 42 }) });\nexpect(deepCss).to.have.deep.property('\\\\.link.\\\\[target\\\\]', 42);\n```\n\n### .size(value)\n\n- **@param** *{ Number }* size\n\nAsserts that the immutable collection has the expected size.\n\n```js\nexpect(List.of(1, 2, 3)).to.have.size(3);\n```\n\nIt can also be used as a chain precursor to a value comparison for the\n`size` property.\n\n```js\nexpect(List.of(1, 2, 3)).to.have.size.least(3);\nexpect(List.of(1, 2, 3)).to.have.size.most(3);\nexpect(List.of(1, 2, 3)).to.have.size.above(2);\nexpect(List.of(1, 2, 3)).to.have.size.below(4);\nexpect(List.of(1, 2, 3)).to.have.size.within(2,4);\n```\n\nSimilarly to `length`/`lengthOf`, `sizeOf` is an alias of `size`:\n\n```js\nexpect(List.of(1, 2, 3)).to.have.sizeOf(3);\n```\n\n## TDD API Reference\n\n### .equal(actual, expected)\n\n- **@param** *{ Collection }* actual\n- **@param** *{ Collection }* expected\n\nAsserts that the values of `actual` are equivalent to the values of\n`expected`. Note that `.strictEqual()` and `.deepEqual()` assert\nexactly like `.equal()` in the context of Immutable data structures.\n\n```js\nvar a = List.of(1, 2, 3);\nvar b = List.of(1, 2, 3);\nassert.equal(a, b);\n```\n\nImmutable data structures should only contain other immutable data\nstructures (unlike `Array`s and `Object`s) to be considered immutable and\nproperly work against `.equal()`, `.strictEqual()` or `.deepEqual()`. See\n[this issue](https://github.com/astorije/chai-immutable/issues/24) for\nmore information.\n\n### .notEqual(actual, expected)\n\n- **@param** *{ Collection }* actual\n- **@param** *{ Collection }* expected\n\nAsserts that the values of `actual` are not equivalent to the values of\n`expected`. Note that `.notStrictEqual()` and `.notDeepEqual()` assert\nexactly like `.notEqual()` in the context of Immutable data structures.\n\n```js\nvar a = List.of(1, 2, 3);\nvar b = List.of(4, 5, 6);\nassert.notEqual(a, b);\n```\n\n### .sizeOf(collection, length)\n\n- **@param** *{ Collection }* collection\n- **@param** *{ Number }* size\n\nAsserts that the immutable collection has the expected size.\n\n```js\nassert.sizeOf(List.of(1, 2, 3), 3);\nassert.sizeOf(new List(), 0);\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/astorije/chai-immutable.git"
  },
  "scripts": {
    "check-style": "jscs chai-immutable.js test/test.js",
    "coverage": "istanbul cover _mocha",
    "coveralls": "npm run coverage && cat ./coverage/lcov.info | coveralls",
    "test": "npm run test-mocha; npm run test-phantomjs; npm run check-style",
    "test-mocha": "mocha",
    "test-phantomjs": "echo 'mocha-phantomjs is temporarily disabled.' # mocha-phantomjs test/index.html"
  },
  "version": "1.6.0"
}
